* tetrominobot
You can call yourself an AI engineer after this one

** details
The program allows the player to create little tetris bots. minus pwn, the intention would be to get
the highest-scoring bot. This would make for a fun misc or koth chall if there's time.

The player gets:
1. a binary
2. a player manual
3. an example program that clears a few lines and dies

** Language
The language is meant to be simple; basically a block of C-like code that is run in a loop. In this
code, you have access to:
- a set of predefined variables
- a set of predefined game functions
- if statements
- a small chunk of memory for counters or whatever the player wants
- maybe macros if I have the time

There won't be loops beyond the outer loop, but workarounds using counters are possible.

todo add grammar

** exploit

*** optional bug: srand (piece generator) control
Intentionally lazy rng so the player can get deterministic and known pieces with a little
effort. makes bug 1 a lot easier.
- Before running the bot we call srand(x) where x is a small unsigned number that is the sum of all
  bytes in the player input
- The parser stops at an EOF character and so the user can put whatever they like after one.
- Like in the real game, pieces are repeatedly drawn from a bag of 7, so this just controls the
  permutations (the player can't just ask for I pieces). however it makes things much easier to
  programmatically generate the after-eof garbage and get the same sequence of pieces every time, no
  matter what they are.

I'll use this bug for now to try and make intended bugs more attractive than any unintended ones.
however, it would make for an interesting challenge to use real randomness.

*** bug 1: libc?? leak
- Like in the real game, pieces existing above the visible board does not kill you
  - you die when a new piece can't spawn (usually in the top-middle of the board)
- An address or some other interesting data is stored above the board in memory
  - libc? address of game memory for a ropchain?
- Piece movement functions return 0 for success or a number describing what the piece ran into
- Like in the real game, there is no "move up" function, but if you are rotating a piece close to
  some obstacles, there is a bunch of "kick" positions that are tried, and many of these positions
  bump the rotated piece up


** potential bugs (not yet implemented)

*** t-spin bug
- the score delta when clearing n lines is array[n] where array is 4 constant ints stored on the
  stack
- t-spins generally give a player more points than the raw amount of lines cleared
  - this is when the piece dropped was a T and the T is "under" some existing pieces
- it is possible to clear 1, 2, or 3 lines with a t-spin
- have the can't-move-T-up check set n=3 (maybe 4? maybe long ints?). Then have the line clearing
  check increment it with additional lines cleared
- score will increment by whatever interesting data lies after the array. player can access the
  score in their bot.

*** arbitrary call
- the ruleset maker treats "function calls" as a table lookup
- TODO player can somehow sneak arbitrary call past the decision tree parser

** flag
- maple{tell the marketing department that we use 99% fewer CPU cycles than competing apps}


* todo
in descending order of importance

- global timeout
- piece timeout?
- guide
- print should only do so when debugging
- malloc tbot
- test game functions

- macros? addressable by number, must be expr
- bot name?

* final bug

currently investivating overwriting argv
^ can't really do; server prog isn't run with any args

note: if the -p flag is found, we bypass the entire -d checking branch

note: do not allow for bot names if i make the misc chall

- bot name can be entered through argv, or through an initial fgets if not found. Debug mode can
  only be enabled thru argv.
  - enter bot name. set argv to this because lazy
  - argv sees -d, so goes into debug mode
- debug mode allows for an extra game function and adds it to the end of the table in the null spot
  (sentinel)
- the player-writable memory is allocated right after
- gfunctable is a record of char *name and func *s
- player will need to
  - call a predetermined string in the program
  - find the pointer to this string and put this in mem[0]
  - find a pointer to whatever they'd like and write it to mem[1]
  - probably write a rop chain
- This is all made easier by the fact the player can re-run the program with a different bot until
  they quit or things segfault.



TODO i need to make the simple bot not use mem[3] so it doesn't segfault in "debug mode" lol

this seems convoluted but i'm imagining it would be pretty easy to be suspicious of the f*table and
the player memory being so close together. i just need to make sure this doesn't open up any boring
ways of finding good addresses (please use the ceiling bug or the t-spin bug)
