* tetrominobot
provided to the player: all filled boxes, score, tick

what does the player write? a spec file? c/asm too pwnable

7-bag may help. There should probably be a button to halt the piece midair

** details
The program allows the player to create little tetris bots, where a bot is just a decision tree.

** exploit

leak is probably more fun than the call

*** bug 1 (libc leak)
- pieces existing above the visible board is OK, as long as they're not yet placed.
- The board should be on the heap or maybe right after the GOT
- Dumping the state of the board yields a list of
  (x,y): colour
  where each color is piece ORed with the board rather than each board spot
- Leak a libc address

*** bug 2: arbitrary call
- the ruleset maker treats "function calls" as a table lookup
- TODO player can somehow sneak arbitrary call past the decision tree parser

*** optional bug: srand control
- hash of the program won't work; i want random pieces for any given bot(???)
- Maybe just a small buffer overflow

** implementation
- player spec file -> list of rules
- game representation
- example spec files

*** game state
- list of pieces where at least one cell is present on the board
- score
- current movable piece
- piece timeout value

** flag
- {tell the marketing department that we use 99% fewer CPU cycles than competing apps}

** player manual
commit() may be used before a drop() in this simulator.

*** spec
RESULT := IFELSE | MOVE
MOVE = input() | left() | right() | rotate_left() | down() | drop() | commit()
COND =
VAR = score | pos(x, y) | number


** nonsense
- undo(), save history for more data thrown everywhere
- if any, the scoreboard-accessing program should probably be in racket
  - should be a limit of 100 moves per piece, else bail
  - in() disabled?
  - or maybe just valid_game = false upon in() or undo()
  - actual random pieces
- color mode
  - color mode that makes address leak harder due to extra bits being
- player manual
